## 스프링 부트 JPA와 데이터 베이스

### [1] JPA 소개

1. 관계형 데이터베이스

   - Oracle, MYSQL, MSSQL 등 쓰임
   - 객체를 관계형 데이터베이스에서 관리하는 것이 무엇보다 중요 -> 모든 코드가 SQL 중심이 되어감
   - 관계형 데이터 베이스는 SQL만 인식 -> 각 테이블마다 기본적인 CRUD 매번 생성(단순 박업 반복)
     - CRUD : Create, Read, Update, Delete
   - SQL을 통해서만 데이터베이스 저장하고 조회 가능하기 때문에 관계형 데이터베이스를 사용하는 상황에서 SQL은 피할 수 없음
   - 패러다임 불일치 : 관계형 데이터베이스 - 어떻게 데이터를 저장할지에 초점 / 객체지향 프로그래밍 - 메세지를 기반으로 기능과 속성을 한 곳에서 관리하는 기술
   - 패러다임이 다른데 객체를 데이터비스에 저장하려니 여러 문제 발생
   - 부모-자식간의 상속 관계와 같은 다양한 객체 모델링을 데이터 베이스로 구현 X -> 개발은 점점 데이터베이스 모델링에 집중<br>
     => JPA는 이런 문제점 해결 위해 등장
   - 서로 지향하는 바가 다른 2개 영역을 중간에서 패러다임 일치시키기 위한 기
   - 개발자는 객체지향 프로그래밍을 하고 JPA가 이를 관계형 데이터베이스에 맞게 SQL을 대신 생성 후 실행
   - SQL에 종속적인 개발 탈출!

2. Spring Data JPA

   - JPA는 인터페이스로서 자바 표준명세서 -> 사용하기 위해서는 구현체 필요
   - 스프링에서 JPA 사용할 때에는 구현체를 직접 다루지 않고 Spring Data JPA 모듈을 활용
   - 관계 : JPA <- Hibernate <- Spring Data JPA
   - 한 단계 더 감싼 이유 : 구현체 교체의 용이성과 저장소 교체의 용이성
     - 구현체 교체의 용이성 : Hibernate이외의 구현체로 쉽게 교페하기 위함
     - 저장소 교체의 용이성 : 관계형 데이터베이스 외의 다른 저장소로 쉽게 교체하기 위함
   - 가능한 이유 : Spring Data 하위 프로젝트들은 기본적인 CRUD 인터페이스가 동일하기 때문
     - save(), findOne(), findAll() 등을 인터페이스로 가짐

3. 실무에서 JPA
   - 실무에서 JPA 사용 X 이유 : 높은 러닝 커브
   - 객체 지향 프로그래밍과 관계형 데이터베이스를 둘 다 이해해야 함

### [2] 프로젝트에 Spring Data JPA 적용하기

1. 의존성 등록

- spring-boot-starter-data-jpa
  - 스프링 부트용 Spring Data JPA 추상화 라이브러리
  - 스프링 부트 버전에 맞춰 자동으로 JPA 관련 라이브러리 버전 관리
- h2
  - 인메모리 관계형 데이터베이스
  - 별도의 설치 없이 프로젝트 의존성마능로 관리 가능
  - 메모리에서 실행 -> 애플리케이션 재시작마다 초기화되는 점을 활용하여 테스트 용도로도 많이 사용
  - 책 : JPA 테스트, 로컬 환경에서의 구동에 사용

2. main > domain 패키지 추가 : 도메인 담을 패키지

- 도메인 : 소프트웨어에 대한 요구사항 또는 문제 영역

  - 게시글, 댓글, 회원, 정산, 결제 등

- posts > Posts 클래스 추가

  - 실제 DB의 테이블과 매칭될 클래스
  - 보통 Entity 클래스라고 함
  - 코드 설명
    - @Entity
      - 테이블과 링크될 클래스임을 나타냄
      - 클래스 이름과 테이블 이름 매칭 시 언더스코어 네이밍(\_) 이용
    - @Id
      - 해당 테이블의 PK 필드
    - @GeneratedValue(strategy = GenerationType.IDENTITY)
      - PK 생성 규칙
      - 스프링 부트 2.0에서는 GenerationType.IDENTITY 추가해야 auto_increment됨
    - @Column
      - 테이블의 컬럼 명시
      - 굳이 선언하지 X 클래스의 필드는 모두 컬럼이 됨
      - 기본값 외에 변경하고 싶은 옵션이 있는 경우 사용
      - length = 500 : 문자열 사이즈를 기본값(255)에서 500으로 늘림
      - columnDefinition = "TEXT" : 타입을 TEXT로 변경
    - 롬복 라이브러리 Annotation
      - @Builder : 클래스의 빌더 패턴 클래스 생성(생성자 상단에 선언 시 생성자에 포함된 필드만 빌더에 포함)
      - @NoArgsConstructor : 기본 생성자 자동 추가
      - @Getter : Getter 메소드 자동 생성
  - Entity 클래스에서는 Setter 메소드를 만들지 않음
    - 클래스의 인스턴스 값들을 언제 어디서 변경할지 명확히 구분 X 차후 기능 변경 시 복잡해짐
    - 대신 값 변경 시 메소드를 추가
  - Setter 없이 어떻게 값을 채워 DB에 삽입?
    - 생성자(여기서는 빌더 클래스) 통해 최종값 채운 후 DB에 삽입 -> 값 변경이 필요한 경우 public 메소드 호출하여 변경

- posts > PostsRepository 클래스 추가 : Posts 클래스로 DB에 접급하게 해줄 JPARepository
  - DB Layer 접근자
  - JPA에서는 Repository로 불리고 인터페이스로 생성
  - 인터페이스 생성 후 JpaRepository<Entity 클래스, PK 타입> 상속 -> 기본 CRUD 메소드 자동 생성
  - Entity 클래스와 기본 Entity Repository는 함께 위치해야 함 -> domain 패키지에서 함께 관리

### [3] Spring Data JPA 테스트 코드 작성하기

1. tests > domain > posts 패키지 추가

   - posts > PostsRepositoryTest 클래스 추가 : save, finaAll 기능 테스트
   - 코드 설명
     - @After
       - JUnit에서 단위 테스트가 끝날 때마다 수행되는 메소드 지정
       - 보통은 배포 전 테스트 때 테스트 간의 데이터 침범 막기 위해 사용(데이터 초기화)
     - postsRepository.save()
       - 테이블 posts에 insert/update 쿼리 실행
       - id값 X : insert / id값 O : update
     - postsRepository.findAll()
       - 테이블 posts의 모든 데이터 조회
     - @SpringBootTest 사용 : H2 데이터베이스 자동 실행

2. 실행된 쿼리 확인하기
   - 실행된 쿼리 로그로 보고 싶음
   - application.properties, application.yml 등의 파일로 한 줄의 코드로 로그 ON/OFF 설정하도록 지원
   - src > main > resources > application.properties 파일 추가
     - 옵션 추가 : `spring.jpa.show-sql=true`
     - `id bigint generated by default as identity` 옵션으로 생성됨 : H2 쿼리 문법 적용되었기 때문
     - 쿼리 로그 MySQL 버전으로 변경(H2는 MySQL 쿼리 수행해도 정상 작동)
       - `spring.jpa.properties.hibernate.dialect.MySQL5InnoDBDialect` 옵션 추가
       - `id bigint not null auto_increment` 옵션 잘 적용됨

### [4] 등록/수정/조회 API 만들기

1. API 구현을 위한 클래스

   1. Request Data를 받을 Dto
   2. API 요청을 받을 Controller
   3. 트랜잭션, 도메인 기능 간의 순서를 보장하는 Service
      - 비즈니스 로직을 처리하는 것이 아님 -> Domain에서 담당
      - 순서 보장의 역할만 수행
      - 기존에 서비스로 처리하던 방식 : 트랜잭션 스크립트
        - 모든 로직이 서비스 클래스 내부에서 처리됨
        - 서비스 계층이 무의미, 객체란 단순히 데이터 덩어리 역할만 수행
      - 도메인 모델에서 처리
        - order, billing, delivery가 각자 본인의 취소 이벤트 처리
        - 서비스 메소드는 트랜잭션과 도메인 간의 순서만 보장

2. 등록/수정/조회 API 생성

- web > PostsApiContorller / web > dto > PostsSaveRequestDto / service > posts > PostsService 클래스 생성
  - @Autowired가 없는데 ..?
    - 스프링에서 Bean 주입받는 방식 : @Autowired, setter, 생성자
    - 생성자로 Bean 객체 주입 받는 방식 가장 권장
    - @RequiredArgdConstructor : final에서 선언된 모든 필드를 인자값으로 하는 생성자를 롬복의 @RequiredArgdConstructor가 대신 생성해 줌
    - 해당 클래스의 의존성 관계가 변경될 때마다 생성자 코드를 계속 수정하는 번거로움 해결해줌
  - Dto 클래스 : Entity 클래스와 유사함에도 생성
    - 절대로 Entity 클래스를 Request/Response 클래스로 사용 X
    - 데이터베이스아 맞닿은 핵심 클래스
    - 화면 변경은 아주 사소한 기능 변경인데 이를 위해 테이블과 연결된 Sntity 클래스를 직접 변경하는 것은 너무 큰 변경
    - Request와 Response용 Dto는 View를 위한 클래스라 자주 변경이 필요함
  - View Layer & DB Layer 역할 분리 중요
    - Controller에서 결과값으로 여러 테이블을 조인해서 줘야 할 경우가 빈번하으로 Entity 클래스만으로 표현하기 어려운 경우가 많음
      => Entity 클래스만와 Controller에서 쓸 Dto는 분리해서 사용해야 함
- 테스트 코드 작성
  - 코드 설명
    - @WebMvcTest 사용 X
      - @WebMvcTest 경우 JPA 기능이 작동 X
      - JPA 기능까지 한번에 테스트 시 @SpringBootTest의 TestRestTemplate 사용
  - 수정/조회 기능도 같은 방식으로 생성 - 수정 기능 - PostsResponseDto : Entity의 필드 중 일부만 사용 -> 생성자로 Entity를 받아 필드에 값을 넣음
  - PostsService update 기능 : 데이터베이스에 쿼리를 날리는 부분 X
    - JPA의 영속성 컨텍스트 때문에 가능
    - 영속성 컨텍스트 : 엔티티를 영구 저장하는 환경
    - JPA의 엔티티 매니저가 활성화된 상태로 트랜잭션 안에서 데이터베이에서 데이터를 가져오면 이 데이터는 영속성 건텍스트가 유지된 상태
    - 이 상태에서 해당 데이터 값 변경 시 트랜잭션이 끄나는 시점에 해당 테이블에 변경분 반영 -> Entity 객테의 값만 변경하면 별도로 Update 쿼리를 날릴 필요 X
    - 이 개념이 더티 체킹(dirty checking)
- 조회 기능
  - 실제 톰캣 실행하여 확인
  - 로컬 환경에서 H2를 데이터베이스로 사용 -> 메모리에서 실행하기 때문에 직접 전금하기 위해서는 웹 콘솔 사용
  - 웹 콘솔 옵션 활성화 : `spring.h2.console.enabled=true` 옵션 추가
  - `SELECT \* FROM posts; insert into posts (author, content, title) values ('author', 'content', 'title');`
    - 작은 따옴표 사용 주의!
  - 등록된 데이터 확인 후 API 요청
    - `http://localhost:8080/api/v1/posts/1` 입력해 API 조회 기능 테스트

### [5] JPA Auditing으로 생성시간/수정시간 자동화하기

- 보통 엔티티에는 해당 데이터의 생성시가놔 수정시간 포함
- 추후 유지보수에 있어 중요한 정보이기 때문
- 매번 DB에 삽입하기 전, 갱시낳기 전에 날짜 데이터를 등록/수정하는 코드가 여기저기 들어가게 됨
- 단순하고 반복적인 코드 매번 추가하기 귀찮음 -> JPA Auditing 사용

1. LocalDate 사용

- domain > BaseTimeEntity 클래스 생성
  - BaseTimeEntity는 모든 Entity의 상위 클래스가 되어 Entity들의 생성시간(createdDate), 수정시간(modifiedDate) 자동 관리해줌
  - 코드 설명
    - @MappedSuperclass : JPA Entity 클래스들이 BaseTimeEntity 상속 시 필드들(createdDate, modifiedDate)도 칼럼으로 인식하도록 함
    - @EntityListeners(AuditingEntityListener.class) : BaseTimeEntity 클래스에 Auditing 기능 포함
    - @CreatedDate : Entity 생성되어 저장 시 시간이 자동 저장
    - @LastModifiedDate : 조회한 Entity의 값 변경 시 시간 자동 저장
- Posts 클래스가 BaseTimeEntity를 상속받도록 변경
- JPA Auditing 어노테이션 활성화할 수 있도록 Application 클래스에 활성화 어노테이션 추가 :

2. JPA Auditing 테스트 코드 작성

- 콘솔에서 시행해보면 실제 시간 잘 저정됨 확인
